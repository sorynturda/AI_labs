\section{Uninformed search}
\subsection{Question 1 - Gasirea unui punct unde se afla mancare folosind Depth-First Search}
% definire cerinta
\par Gasirea unui punct unde se afla mancare folosind Depth First Search
\par \textbf{Depth-First Search} este un algoritm utilizat pentru explorarea grafurilor sau arborilor. Scopul acestuia este de a traversa toate nodurile unui graf, urmărind o cale cât mai adâncă înainte de a reveni și a explora căile neexplorate.
% prezentare algoritm/metoda

\begin{algorithm}
\caption{Depth First Search}
\begin{algorithmic}[1]
\Function{DFS}{problem}
    \State stack $\gets$ Stack()
    \State visited $\gets \emptyset$
    \State node $\gets$ problem.getStartState()
    \State stack.push((node, [ ]))
    
    \While{not stack.isEmpty()}
        \State position, path $\gets$ stack.pop()
        \If{position $\notin$ visited}
            \State visited.add(position)
            \If{problem.isGoalState(position)}
                \Return path
            \EndIf
            \For{(successor, direction, cost) in problem.getSuccessors(position)}
                \If{successor $\notin$ visited}
                    \State stack.push((successor, path + [direction]))
                \EndIf
            \EndFor
        \EndIf
    \EndWhile \\
    \Return [ ]
\EndFunction
\end{algorithmic}
\end{algorithm}
% optional prezentare cod
% optional explicatii suplimentare cod

% comentarii/observatii asupra performantei/rezultatelor/complexitatii/algoritmului
\par Complexitatea algoritmului în:

\begin{itemize}
    \item Timp: $O(b^m)$ unde b este factorul de ramificare (numarul mediu de succesori) si d este adancimea maxima a arborelui
    \item Spațiu: $O(b*m)$ - trebuie sa stocam nodurile de pe calea curenta plus nodurile de pe acelasi nivel 
\end{itemize}

\par Avantaje:
\begin{itemize}
	\item Implementare simpla si intuitiva
	\item Necesita mai putina memorie decat BFS deoarece exploreaza in adancime
	\item Poate gasi rapid o solutie daca aceasta se afla pe o ramura explorata devreme
\end{itemize}

\par Dezavantaje:
\begin{itemize}
	\item Nu garanteaza gasirea celui mai scurt drum
	\item Poate ramane blocata explorând cai foarte lungi/infinite daca nu se implementeaza detectia ciclurilor
\end{itemize}

\pagebreak

\subsection{Question 2 - Breadth-first search}
\par \textbf{Breadth-first search} este un algoritm utilizat pentru traversarea și căutarea în grafuri sau arbori. Spre deosebire de DFS, BFS explorează nodurile pe niveluri, adică parcurge mai întâi toate nodurile aflate la o anumită distanță de nodul de start înainte de a trece la nodurile mai îndepărtate. BFS este implementat utilizând o coadă pentru a gestiona ordinea vizitării nodurilor.
% TODO: de completat
% + q3 din project 1

\begin{algorithm}
\caption{Breadth First Search}
\begin{algorithmic}[1]
\Function{BFS}{problem}
    \State queue $\gets$ Queue()
    \State visited $\gets \emptyset$
    \State node $\gets$ problem.getStartState()
    \State queue.push((node, [ ]))
    
    \While{not queue.isEmpty()}
        \State position, path $\gets$ queue.pop()
        \If{position $\notin$ visited}
            \State visited.add(position)
            \If{problem.isGoalState(position)}
                \Return path
            \EndIf
            \For{(successor, direction, cost) in problem.getSuccessors(position)}
                \If{successor $\notin$ visited}
                    \State queue.push((successor, path + [direction]))
                \EndIf
            \EndFor
        \EndIf
    \EndWhile \\
    \Return [ ]
\EndFunction
\end{algorithmic}
\end{algorithm}
\par Complexitatea algoritmului în:

\begin{itemize}
    \item Timp: $O(b^{d+1})$ unde $b$ este factorul de ramificare și $d$ este adâncimea la care se găsește prima soluție
    \item Spațiu: $O(b^d)$ - trebuie să stocheze toate nodurile de pe nivelul curent și următorul nivel
\end{itemize}
\par BFS este optimal, spațiul fiind o mare problemă
\par Avantaje:
\begin{itemize}
	\item Garantează găsirea celei mai scurte căi până la soluție
	\item Explorează sistematic toate nodurile de pe un nivel înainte de a trece la următorul
	\item Potrivit pentru spații de căutare cu factor de ramificare mic și soluții la adâncimi mici
\end{itemize}

\par Dezavantaje:
\begin{itemize}
	\item Consumă mai multă memorie decât DFS deoarece trebuie să stocheze toate nodurile de pe un nivel
	\item Nu este potrivit pentru probleme cu ramuri infinite
	\item Poate fi ineficient pentru spații de căutare mari cu soluții la adâncimi mari
\end{itemize}

\pagebreak

\section{Informed search}
% q4 - q8 din project 1
\subsection{Question 4 - A* search  algorithm}
% q4 din project 1
\begin{algorithm}
\caption{A* Search}
\begin{algorithmic}[1]
\Function{AStarSearch}{problem, heuristic}
    \State start $\gets$ problem.getStartState()
    \State queue $\gets$ PriorityQueue()
    \State bestCost $\gets$ \{start: 0\}
    \State queue.push((start, []), 0)
    
    \While{not queue.isEmpty()}
        \State pos, path $\gets$ queue.pop()
        \If{problem.isGoalState(pos)}
            \Return path
        \EndIf
        
        \For{(successor, direction, cost) in problem.getSuccessors(pos)}
            \If{bestCost[pos] + cost < bestCost.setdefault(successor, $\infty$)}
                \State bestCost[successor] $\gets$ cost + bestCost[pos]
                \State newCost $\gets$ bestCost[successor] + heuristic(successor, problem)
                \State queue.update((successor, path + [direction]), newCost)
            \EndIf
        \EndFor
    \EndWhile \\
	\Return [ ]
\EndFunction
\end{algorithmic}
\end{algorithm}

\par Implementare si Structuri de Date:
\begin {itemize}
	\item Coadă cu priorități (PriorityQueue) pentru selectarea nodului cu cost minim
	\item Menține un dicționar pentru costurile minime până la fiecare nod
	\item Funcția de prioritate f(n) = g(n) + h(n), unde:
	\begin {itemize}
		\item g(n) este costul real până la nodul n
		\item h(n) este euristica Manhattan pentru distanța estimată până la țintă
	\end {itemize}
\end {itemize} 

\par Euristica Manhattan:

\begin {itemize}
	\item Calculează $|x1-x2|$ + $|y1-y2|$ între poziția curentă și pozitia urmatoare
	\item Este admisibilă (nu supraestimeaza costul real) si consistenta (respecta inegalitatea triunghiului)
\end {itemize}

\par Complexitate:
\begin {itemize}
	\item Timp: $O(b^d)$ 
	\item Spațiu: $O(b^d)$ - trebuie să păstreze în memorie nodurile explorate
\end {itemize}

\par Avantaje:
\begin {itemize}
	\item Garantează găsirea drumului optim când euristica este admisibilă
	\item Mai eficient decât BFS/DFS prin folosirea euristicii pentru ghidarea căutării
	\item Explorează mai puține noduri decât algoritmii de căutare neinformată
\end {itemize}

\par Dezavantaje:
\begin {itemize}
	\item Spatiul utilizat
	\item Implementarea este mai complexă decât BFS/DFS
\end {itemize}

\pagebreak

\section{Adversarial search}
% q1-q3 din project2
\subsection{Question 9 - Improve the ReflexAgent} 
% q1 din project 2